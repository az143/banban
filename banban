#!/usr/bin/perl
#   $Id: banban,v 1.3 2013/06/06 04:54:31 az Exp az $
# 
#   File:		banban
#   Date:		01 Jun 2013 16:40:52
#   Author:		Alexander Zangerl <az@snafu.priv.at>
# 
#   Abstract:
#	slimmed down but slightly brighter variation of fail2ban
#
use strict;
use File::Tail;
use Data::Dumper;
use YAML::Tiny;
use Getopt::Std;
use POSIX;
use Sys::Syslog;
use Proc::PID::File;
use File::Basename;

my $cffile="/etc/banban.yml";
my $facility="local2";
my %opts;

getopts("fs",\%opts) or die "usage: $0 [-f][-s]\n-f: foreground and debug info\n-s: simulate only\n";
my ($config)=YAML::Tiny::LoadFile($cffile) or die "can't open $cffile: $!\n";

# compile all regexps
my @cregood=map qr/$_/, @{$config->{goodpatterns}};
my @alltargets;
for my $bname (keys %{$config->{blocktypes}})
{
    my $thisblock=$config->{blocktypes}->{$bname};
    $thisblock->{crebad}=[map qr/$_/, @{$thisblock->{patterns}}];
    push @alltargets,$thisblock->{target} if (!grep($_ eq $thisblock->{target},@alltargets)); # cheap and lazy, i know
}

my %mnames=(Jan=>0,Feb=>1,Mar=>2,Apr=>3,May=>4,Jun=>5,Jul=>6,Aug=>7,Sep=>8,Oct=>9,Nov=>10,Dec=>11);
my %offenders;			# key ip, value list of occurrences


if (!$opts{f})
{
    openlog(basename($0),"pid",$facility);
    chdir '/' or die "Can't chdir to /: $!";
    open STDIN, '/dev/null'  or die "Can't read /dev/null: $!";
    open STDOUT, '>/dev/null' or die "Can't write to /dev/null: $!";
    
    $SIG{__DIE__}=sub { die @_ if $^S; syslog("crit",$_[0]."\n"); };

    defined(my $pid = fork) or die "Can't fork: $!";
    exit if $pid;

    die basename($0)." already running, exiting!\n" 
	if (Proc::PID::File->running());

    syslog("info","starting to tail ".join(" ",@{$config->{logfiles}}));
}
	   
# open all logfiles for tailing
my @tails=map File::Tail->new(name=>$_),@{$config->{logfiles}};

while (1)
{
    my ($nready,$timeleft,@mustread)=File::Tail::select(undef,undef,undef,5,@tails);
    next if (!$nready);

    my $thisyear=(localtime(time))[5];
    for my $fh (@mustread)
    {
	READLOOP: for my $ll ($fh->read)
	{
	    chomp $ll;
	    my ($month,$day,$time,$servername,$line)=split(/\s+/,$ll,5);
	    my @tcomps=split(/:/,$time);
	    if (!$month || !$day || !$time || !@tcomps)
	    {
		logit("ignoring dud line \"$ll\"");
		next READLOOP;
	    }
	    # first look for unblock-worthy behaviour
	    for my $re (@cregood)
	    {
		if ($line =~ $re)
		{
		    my $ip=$+{ip};
		    next READLOOP if (ignoreip($ip));
		    logit("unblocking ip $ip");
		    blockunblock($ip,undef) if (!$opts{s});
		    delete $offenders{$ip};
		    next READLOOP;
		}
	    }
	    # then check for offenses
	    BLOCKTYPE: for my $bname (keys %{$config->{blocktypes}})
	    {
		for my $re (@{$config->{blocktypes}->{$bname}->{crebad}})
		{
		    if ($line =~ $re)
		    {
			my $ip=$+{ip};
			next READLOOP if (ignoreip($ip));

			my $when=POSIX::mktime((reverse @tcomps),$day,$mnames{$month},$thisyear);
			# print "bad pattern for ip $ip on line \"$line\", at time $when\n";

			$offenders{$ip}||=[];
			push @{$offenders{$ip}},$when;

			my $cutoff=time-$config->{blocktypes}->{$bname}->{interval};

			my $countbad=scalar grep($_>$cutoff,@{$offenders{$ip}});
			if ($countbad>=$config->{blocktypes}->{$bname}->{minocc})
			{
			    logit("ip $ip offense $countbad, blocktype $bname");
			    blockunblock($ip,$bname) if (!$opts{s});
			}
			# limit mem growth, keep only last 10 hits in history
			if (@{$offenders{$ip}}>10)
			{
			    $offenders{$ip}=[@{$offenders{$ip}}[-10..-1]];
			}
			next BLOCKTYPE;
		    }
		}
	    }
	}
    }
}
exit (0);

# blocktype undef -> unblock, otherwise block respective list and settings
sub blockunblock
{
    my ($ip,$btype)=@_;

    if (!$btype)
    {
	for my $tname (@alltargets)
	{
	    my $tfn="/proc/net/xt_recent/$tname";
	    open(F,">$tfn") or die "can't open $tfn: $!\n";
	    print F "-$ip\n";
	    close(F);
	}
    }
    else
    {
	my $tfn="/proc/net/xt_recent/".$config->{blocktypes}->{$btype}->{target};
	open(F,">$tfn") or die "can't open $tfn: $!\n";
	print F "+$ip\n";
	close(F);

	# also nix any existing connections if requested
	if ($config->{blocktypes}->{$btype}->{resetconns})
	{
	    system("/usr/sbin/conntrack","-D","-s",$ip);
	}
    }
}

# returns 1 if ip is in ignorenets
sub ignoreip
{
    my ($ip)=@_;
    return 0 if (!$config->{ignorenets});

    my @digits=split(/\./,$ip);
    my $intip=$digits[0]*(1<<24)+$digits[1]*(1<<16)
	+$digits[2]*(1<<8)+$digits[3];

    for my $netspec (@{$config->{ignorenets}})
    {
	my ($net,$len)=split(m!/!,$netspec);
	@digits=split(/\./,$net);
	my $intmask=(0xffffffff<<(32-$len))&0xffffffff;
	my $intnet=($digits[0]*(1<<24)+$digits[1]*(1<<16)
		    +$digits[2]*(1<<8)+$digits[3])&$intmask;
	return 1 if (($intip&$intmask) == $intnet);
    }
}

sub logit
{
    my ($msg)=@_;
    if (!$opts{f})
    {
	syslog("info",$msg);
    }
    else
    {
	print STDERR $msg,"\n";
    }
}
